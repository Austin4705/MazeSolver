import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;


/**Main class for outputting the graph in any format*/
public class graphWriter {

    /**main constructor*/
    public graphWriter(){
        embeddGraph();
    }


    /**takes the path lists that were generated by dijkstras and embedds them into the actual multidimensional array*/
    public void embeddGraph(){
        //for every list
        for(int i = 0; i < mazeData.getInstance().listDir.size(); i++){
            for(int j = 0; j < mazeData.getInstance().listDir.get(i).toArray().length; j++){
                node n = (node)mazeData.getInstance().listDir.get(i).toArray()[j];
                int a = mazeData.getInstance().data.get(n.idx);
                //if the node isn't a start or end node convert type to path node
                if(!(a == 2 || a == 3)){
                    mazeData.getInstance().data.set(n.idx, 4);
                }
            }
        }
    }

    /**takes the maze in the multidimensional array that has the embedding of the path to solve the maze, uses it to write into a suggested file
     * @param fileName location to end up*/
    public void writeToFile(String fileName){
        try{
            fileName = inputSystem.fullPathStr(fileName);
            FileOutputStream x = new FileOutputStream(fileName); x = null;
            //open the node, wire out the maze by looping through and every reset of a counter in dimension print a new line,
            //forms the nice graph separation
            FileWriter w = new FileWriter(fileName);
            mazeData maze = mazeData.getInstance();
            w.write("Solved Maze:\n");
            w.write(mazeData.intToChar(maze.data.get(new int[maze.data.dimensions().length])));
            for(int i = 1; i < maze.data.size(); i++){
                int[] curArr = maze.loopDimensions(i);
                int[] prevArr = maze.loopDimensions(i-1);
                for(int j = 0; j < curArr.length; j++){
                    if(curArr[j] < prevArr[j]){
                        w.write("\n");
                    }
                }
                w.write(mazeData.intToChar(maze.data.get(curArr)));
            }
            w.close();
        }
        catch (FileNotFoundException e){
            System.out.println("File not Found");
            e.printStackTrace();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**write graph to cmd, similar style to writeToFile*/
    public void writeToCmd(){
        //again, could make it a more combined command and pass around either system.out or a file but this is simpler
        mazeData maze = mazeData.getInstance();
        System.out.print(mazeData.intToChar(maze.data.get(new int[maze.data.dimensions().length])));
        for(int i = 1; i < maze.data.size(); i++){
            int[] curArr = maze.loopDimensions(i);
            int[] prevArr = maze.loopDimensions(i-1);
            for(int j = 0; j < curArr.length; j++){
                if(curArr[j] < prevArr[j]){
                    System.out.print("\n");
                }
            }
            System.out.print(mazeData.intToChar(maze.data.get(curArr)));
        }
    }

    /**Write to a stl. Uses ASCII ending stl encoding. takes in param of what parts of maze to print and uses
     *  vocalized nature to print it
     * @param fileName name of file to output
     * @param maze if want print maze
     * @param path if want print path
     * @param start if want print start
     * @param end if want print end
     * @param whiteSpace if want print whitespace
     * */
    public void writeTo3dObj(String fileName, boolean maze, boolean path, boolean start, boolean end, boolean whiteSpace){
        try{
            //open and init file. Output stream thing is to make a new file if not file not exist, but also work if one does exist
            fileName = inputSystem.fullPathStr(fileName);
            FileOutputStream x = new FileOutputStream(fileName); x = null;
            FileWriter w = new FileWriter(fileName);
            String s = "";
            //based on conditions, add the objects together based on obj call
            if(maze){
                s += createObj("mazes", 1);
            }
            if(path){
                s += createObj("paths", 4);
            }
            if(start){
                s += createObj("startPos", 2);
            }
            if(end){
                s += createObj("endPos", 3);
            }
            if(whiteSpace){
                s += createObj("whiteSpace", 0);
            }
            //write and close file
            w.write(s.toString());
            w.close();
        }
        catch (FileNotFoundException e){
            System.out.println("File not Found");
            e.printStackTrace();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**Helper function to create the object
     * @param objName name of object
     * @param valToWrite what type of val in arrary to look for
     * @return obj created*/
    private String createObj(String objName, int valToWrite){
        mazeData maze = mazeData.getInstance();
        StringBuilder s = new StringBuilder("solid " + objName + "\n");
        //look through entire maze, if value matches valToWrite, draw a cube at that dimension
        if(maze.data.dimensions().length <= 3){
            int[] dim = new int[3];
            for(int i = 0; i < maze.data.size(); i++){
                int val = maze.data.get(i);
                if(val == valToWrite){
                    int[] xd = maze.loopDimensions(i);
                    if(maze.data.dimensions().length >= 1) dim[0] = xd[0];
                    if(maze.data.dimensions().length >= 2) dim[1] = xd[1];
                    if(maze.data.dimensions().length >= 3) dim[2] = xd[2];
                    s.append(cube(dim));
                }
            }
            String endStr = "endsolid " + objName + "\n";
            s.append(endStr);
        }
        else{
            throw new RuntimeException("Over 3 dimensions");
        }
        return s.toString();
    }

    /**Helper function to draw a cube
     * @param xd where in space to draw one
     * @return stl code to make cube*/
    private String cube(int[] xd){
        StringBuilder s = new StringBuilder();
        //connect every point in the space of the cube together with faces, can make issues but works good enough
        for(int i = 0; i < 8; i++){
            for(int j = i; j < 8; j++){
                for(int k = j; k < 8; k++){
                    if(!(i == j || j == k)){
                        int[] iA = pointPlus(pointId(i), xd);
                        int[] jA = pointPlus(pointId(j), xd);
                        int[] kA = pointPlus(pointId(k), xd);
                        s.append(oneFace(iA, jA, kA));
                    }
                }
            }
        }
        return s.toString();
    }



     /**creates a mapping to all potention poiuts at home world cube to ids
      * @param id main id
      * @return the dimensions
      * */
    private int[] pointId(int id){
        int[][] ida = {
                {0, 0 ,0},
                {1, 0, 0}, {0, 1, 0}, {0, 0, 1},
                {1, 1, 0}, {1, 0, 1}, {0, 1, 1},
                {1, 1, 1}
        };
        return ida[id];
    }

/**converts the xyz of big space into the subspace including what point of cube it is
 * @param cur current point of cube
 * @param xyz namespace location
 * @return summed point*/
    private int[] pointPlus(int[] cur, int[] xyz){
        cur[0] += xyz[0]; cur[1] += xyz[1]; cur[2] += xyz[2];
        return cur;
    }

    /**creates one face based on 3 point vertices
     * @param a point1
     * @param b point 2
     * @param c point 3
     * @return string to generate that face.*/
    private String oneFace(int[] a, int[] b, int[] c) {
        String s = "";
        s += "facet normal 0 0 0\n";
        s += "\touter loop\n";
        s += "vertex " + a[0] + ", " + a[1] + ", " + a[2] + ",\n";
        s += "vertex " + b[0] + ", " + b[1] + ", " + b[2] + ",\n";
        s += "vertex " + c[0] + ", " + c[1] + ", " + c[2] + ",\n";
        s += "\tendloop\n";
        s += "endfacet\n";
        return s;
    }
}
